name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Get version
        id: get_version
        run: |
          echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: context.ref.replace('refs/tags/', ''),
              name: `Basitune v${{ steps.get_version.outputs.VERSION }}`,
              body: 'Download the appropriate package for your platform below.',
              draft: false,
              prerelease: false
            })
            return data.id

  build-release:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
          - platform: macos-latest
            target: x86_64-apple-darwin
            name: macos
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows

    runs-on: ${{ matrix.platform }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies (Ubuntu)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev \
            build-essential \
            curl \
            wget \
            file \
            libxdo-dev \
            libssl-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            imagemagick

      - name: Install dependencies (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          brew install --cask xquartz

      - name: Install NPM dependencies
        run: npm install

      - name: Prepare frontend assets
        run: |
          mkdir -p dist
          cp index.html dist/

      - name: Build Basitune
        run: npm run build -- --target ${{ matrix.target }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || 'sk-dummy-key-for-ci-build' }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}

      - name: Upload Release Assets (Linux)
        if: matrix.platform == 'ubuntu-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const bundleDir = 'src-tauri/target/release/bundle';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Upload .deb
            const debFiles = fs.readdirSync(path.join(bundleDir, 'deb'));
            for (const file of debFiles.filter(f => f.endsWith('.deb'))) {
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: file,
                data: fs.readFileSync(path.join(bundleDir, 'deb', file))
              });
            }
            
            // Upload .rpm
            const rpmFiles = fs.readdirSync(path.join(bundleDir, 'rpm'));
            for (const file of rpmFiles.filter(f => f.endsWith('.rpm'))) {
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: file,
                data: fs.readFileSync(path.join(bundleDir, 'rpm', file))
              });
            }

      - name: Upload Release Assets (macOS)
        if: matrix.platform == 'macos-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const bundleDir = 'src-tauri/target/release/bundle';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Upload .dmg
            const dmgFiles = fs.readdirSync(path.join(bundleDir, 'dmg'));
            for (const file of dmgFiles.filter(f => f.endsWith('.dmg'))) {
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: file,
                data: fs.readFileSync(path.join(bundleDir, 'dmg', file))
              });
            }

      - name: Upload Release Assets (Windows)
        if: matrix.platform == 'windows-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const bundleDir = 'src-tauri/target/release/bundle';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Upload .msi
            const msiFiles = fs.readdirSync(path.join(bundleDir, 'msi'));
            for (const file of msiFiles.filter(f => f.endsWith('.msi'))) {
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: file,
                data: fs.readFileSync(path.join(bundleDir, 'msi', file))
              });
            }
            
            // Upload .exe (NSIS installer)
            const nsisFiles = fs.readdirSync(path.join(bundleDir, 'nsis'));
            for (const file of nsisFiles.filter(f => f.endsWith('.exe'))) {
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: file,
                data: fs.readFileSync(path.join(bundleDir, 'nsis', file))
              });
            }

  create-updater-manifest:
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version
        id: get_version
        run: |
          echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
      
      - name: Create updater manifest
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.get_version.outputs.VERSION }}';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Get all release assets
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            // Create update manifest
            const manifest = {
              version,
              notes: release.body || 'New version available',
              pub_date: new Date().toISOString(),
              platforms: {}
            };
            
            const detectArch = (name) => {
              if (/aarch64|arm64/i.test(name)) return 'aarch64';
              if (/armv?7/i.test(name)) return 'armv7';
              return 'x86_64';
            };
            
            const addPlatform = (platformKey, asset) => {
              if (asset?.browser_download_url) {
                manifest.platforms[platformKey] = {
                  signature: '',
                  url: asset.browser_download_url
                };
              }
            };
            
            for (const asset of release.assets) {
              if (asset.name.endsWith('.deb') || asset.name.endsWith('.rpm') || asset.name.endsWith('.AppImage')) {
                addPlatform(`linux-${detectArch(asset.name)}`, asset);
              } else if (asset.name.endsWith('.dmg')) {
                addPlatform(`darwin-${detectArch(asset.name)}`, asset);
              } else if (asset.name.endsWith('.msi') || asset.name.endsWith('.exe')) {
                addPlatform(`windows-${detectArch(asset.name)}`, asset);
              }
            }
            
            // Upload latest.json
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: 'latest.json',
              data: JSON.stringify(manifest, null, 2)
            });
