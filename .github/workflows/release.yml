name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Get version
        id: get_version
        run: |
          echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: context.ref.replace('refs/tags/', ''),
              name: `Basitune v${{ steps.get_version.outputs.VERSION }}`,
              body: 'Download the appropriate package for your platform below.',
              draft: false,
              prerelease: false
            })
            return data.id

  build-release:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
          - platform: macos-latest
            target: x86_64-apple-darwin
            name: macos
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows

    runs-on: ${{ matrix.platform }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies (Ubuntu)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev \
            build-essential \
            curl \
            wget \
            file \
            libxdo-dev \
            libssl-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            imagemagick

      - name: Install dependencies (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          brew install --cask xquartz

      - name: Install NPM dependencies
        run: npm install

      - name: Prepare frontend assets
        run: |
          mkdir -p dist
          cp index.html dist/

      - name: Debug - Check secrets are set
        shell: bash
        run: |
          echo "=== SECRET CHECK ==="
          if [ -z "$TAURI_SIGNING_PRIVATE_KEY" ]; then
            echo "ERROR: TAURI_SIGNING_PRIVATE_KEY is empty!"
          else
            echo "TAURI_SIGNING_PRIVATE_KEY is set"
            echo "Length: $(echo -n "$TAURI_SIGNING_PRIVATE_KEY" | wc -c)"
            echo "Lines: $(echo "$TAURI_SIGNING_PRIVATE_KEY" | wc -l)"
            echo "First line: $(echo "$TAURI_SIGNING_PRIVATE_KEY" | head -1)"
          fi
          
          if [ -z "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ]; then
            echo "ERROR: TAURI_SIGNING_PRIVATE_KEY_PASSWORD is empty!"
          else
            echo "TAURI_SIGNING_PRIVATE_KEY_PASSWORD is set"
            echo "Length: $(echo -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" | wc -c)"
          fi
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Debug - Write key to file and test
        shell: bash
        run: |
          echo "=== FILE TEST ==="
          printf '%s' "$TAURI_SIGNING_PRIVATE_KEY" > /tmp/test-key
          echo "File size: $(wc -c < /tmp/test-key)"
          echo "File lines: $(wc -l < /tmp/test-key)"
          echo "File first line: $(head -1 /tmp/test-key)"
          echo "Attempting to sign test file..."
          echo "test" > /tmp/test.txt
          npx @tauri-apps/cli signer sign /tmp/test.txt -f /tmp/test-key --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" 2>&1 || echo "Sign test FAILED"
          rm -f /tmp/test-key /tmp/test.txt /tmp/test.txt.sig
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Write signing key to file for build (Unix)
        if: matrix.platform != 'windows-latest'
        shell: bash
        run: |
          printf '%s' "$TAURI_SIGNING_PRIVATE_KEY" > /tmp/tauri-signing-key
          echo "=== Key file created at /tmp/tauri-signing-key ==="
          wc -c /tmp/tauri-signing-key
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}

      - name: Write signing key to file for build (Windows)
        if: matrix.platform == 'windows-latest'
        shell: bash
        run: |
          printf '%s' "$TAURI_SIGNING_PRIVATE_KEY" > "$RUNNER_TEMP/tauri-signing-key"
          echo "=== Key file created at $RUNNER_TEMP/tauri-signing-key ==="
          wc -c "$RUNNER_TEMP/tauri-signing-key"
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}

      - name: Build Basitune (Unix)
        if: matrix.platform != 'windows-latest'
        run: |
          echo "=== BUILD START ==="
          npm run build
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || 'sk-dummy-key-for-ci-build' }}
          TAURI_SIGNING_PRIVATE_KEY: /tmp/tauri-signing-key
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Build Basitune (Windows)
        if: matrix.platform == 'windows-latest'
        shell: bash
        run: |
          echo "=== BUILD START ==="
          echo "Key file path: $RUNNER_TEMP/tauri-signing-key"
          export TAURI_SIGNING_PRIVATE_KEY="$RUNNER_TEMP/tauri-signing-key"
          npm run build
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || 'sk-dummy-key-for-ci-build' }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Upload Release Assets (Linux)
        if: matrix.platform == 'ubuntu-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const bundleDir = 'src-tauri/target/release/bundle';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Upload .deb and .sig
            const debDir = path.join(bundleDir, 'deb');
            if (fs.existsSync(debDir)) {
              const debFiles = fs.readdirSync(debDir);
              for (const file of debFiles.filter(f => f.endsWith('.deb') || f.endsWith('.sig'))) {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(path.join(debDir, file))
                });
              }
            }
            
            // Upload .rpm and .sig
            const rpmDir = path.join(bundleDir, 'rpm');
            if (fs.existsSync(rpmDir)) {
              const rpmFiles = fs.readdirSync(rpmDir);
              for (const file of rpmFiles.filter(f => f.endsWith('.rpm') || f.endsWith('.sig'))) {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(path.join(rpmDir, file))
                });
              }
            }

      - name: Upload Release Assets (macOS)
        if: matrix.platform == 'macos-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const bundleDir = 'src-tauri/target/release/bundle';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Upload .dmg and .sig
            const dmgDir = path.join(bundleDir, 'dmg');
            if (fs.existsSync(dmgDir)) {
              const dmgFiles = fs.readdirSync(dmgDir);
              for (const file of dmgFiles.filter(f => f.endsWith('.dmg') || f.endsWith('.sig'))) {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(path.join(dmgDir, file))
                });
              }
            } else {
              console.log('DMG directory not found, skipping DMG upload');
            }

      - name: Upload Release Assets (Windows)
        if: matrix.platform == 'windows-latest'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const bundleDir = 'src-tauri/target/release/bundle';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Upload .msi and .sig
            const msiDir = path.join(bundleDir, 'msi');
            if (fs.existsSync(msiDir)) {
              const msiFiles = fs.readdirSync(msiDir);
              for (const file of msiFiles.filter(f => f.endsWith('.msi') || f.endsWith('.sig'))) {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(path.join(msiDir, file))
                });
              }
            }
            
            // Upload .exe (NSIS installer) and .sig
            const nsisDir = path.join(bundleDir, 'nsis');
            if (fs.existsSync(nsisDir)) {
              const nsisFiles = fs.readdirSync(nsisDir);
              for (const file of nsisFiles.filter(f => f.endsWith('.exe') || f.endsWith('.sig'))) {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(path.join(nsisDir, file))
                });
              }
            }

  create-updater-manifest:
    needs: [create-release, build-release]
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version
        id: get_version
        run: |
          echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
      
      - name: Create updater manifest
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.get_version.outputs.VERSION }}';
            const releaseId = ${{ needs.create-release.outputs.release_id }};
            
            // Get all release assets
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            // Create update manifest
            const manifest = {
              version,
              notes: release.body || 'New version available',
              pub_date: new Date().toISOString(),
              platforms: {}
            };
            
            const detectArch = (name) => {
              if (/aarch64|arm64/i.test(name)) return 'aarch64';
              if (/armv?7/i.test(name)) return 'armv7';
              return 'x86_64';
            };
            
            // Build a map of binaries to their signatures
            const signatures = {};
            for (const asset of release.assets) {
              if (asset.name.endsWith('.sig')) {
                const binaryName = asset.name.replace('.sig', '');
                const response = await github.request('GET {url}', { url: asset.url, headers: { accept: 'application/octet-stream' } });
                signatures[binaryName] = Buffer.from(response.data).toString('utf8');
              }
            }
            
            const addPlatform = (platformKey, asset) => {
              if (asset?.browser_download_url) {
                manifest.platforms[platformKey] = {
                  signature: signatures[asset.name] || '',
                  url: asset.browser_download_url
                };
              }
            };
            
            for (const asset of release.assets) {
              if (asset.name.endsWith('.deb') || asset.name.endsWith('.rpm') || asset.name.endsWith('.AppImage')) {
                addPlatform(`linux-${detectArch(asset.name)}`, asset);
              } else if (asset.name.endsWith('.dmg')) {
                addPlatform(`darwin-${detectArch(asset.name)}`, asset);
              } else if (asset.name.endsWith('.msi') || asset.name.endsWith('.exe')) {
                addPlatform(`windows-${detectArch(asset.name)}`, asset);
              }
            }
            
            // Upload latest.json
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: 'latest.json',
              data: JSON.stringify(manifest, null, 2)
            });
